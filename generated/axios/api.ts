/* tslint:disable */
/* eslint-disable */
/**
 * Moneybird OpenAPI spec
 * OpenAPI spec for Moneybird: https://developer.moneybird.com/
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Object describing an administration.
 * @export
 * @interface Administration
 */
export interface Administration {
    /**
     * The ID of the administration.
     * @type {string}
     * @memberof Administration
     */
    'id'?: string;
    /**
     * The name of the administration.
     * @type {string}
     * @memberof Administration
     */
    'name'?: string;
    /**
     * The language of the administration.
     * @type {string}
     * @memberof Administration
     */
    'language'?: string;
    /**
     * The currency used in the administration.
     * @type {string}
     * @memberof Administration
     */
    'currency'?: string;
    /**
     * The country of the administration.
     * @type {string}
     * @memberof Administration
     */
    'country'?: string;
    /**
     * The timezone of the administration.
     * @type {string}
     * @memberof Administration
     */
    'time_zone'?: string;
    /**
     * The access level of the current user to the administration.
     * @type {string}
     * @memberof Administration
     */
    'access'?: string;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'administration_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'attachable_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'attachable_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'content_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'rotation'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'updated_at'?: string;
}
/**
 * Object which describes a contact.
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof Contact
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'zipcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'city'?: string;
    /**
     * ISO two-character country code, e.g. NL or DE.
     * @type {string}
     * @memberof Contact
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phone'?: string;
    /**
     * Can be Email, Simplerinvoicing, Post or Manual.
     * @type {string}
     * @memberof Contact
     */
    'delivery_method'?: string;
    /**
     * Will be assigned automatically if empty. Should be unique for the administration.
     * @type {string}
     * @memberof Contact
     */
    'customer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'tax_number'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof Contact
     */
    'firstname'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof Contact
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'chamber_of_commerce'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'bank_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'send_invoices_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof Contact
     */
    'send_invoices_to_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'send_estimates_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof Contact
     */
    'send_estimates_to_email'?: string;
    /**
     * When true, all other SEPA fields are required.
     * @type {boolean}
     * @memberof Contact
     */
    'sepa_active'?: boolean;
    /**
     * Should be a valid IBAN.
     * @type {string}
     * @memberof Contact
     */
    'sepa_iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'sepa_iban_account_name'?: string;
    /**
     * Should be a valid BIC.
     * @type {string}
     * @memberof Contact
     */
    'sepa_bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'sepa_mandate_id'?: string;
    /**
     * Should be a date in the past.
     * @type {string}
     * @memberof Contact
     */
    'sepa_mandate_date'?: string;
    /**
     * Can be RCUR, FRST, OOFF or FNAL.
     * @type {string}
     * @memberof Contact
     */
    'sepa_sequence_type'?: string;
    /**
     * Can be 0002, 0007, 0009, 0037, 0060, 0088, 0096, 0097, 0106, 0130, 0135, 0142, 0151, 0183, 0184, 0190, 0191, 0192, 0193, 0195, 0196, 0198, 0199, 0200, 0201, 0202, 0204, 0208, 0209, 9901, 9902, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9915, 9917, 9918, 9919, 9920, 9921, 9922, 9923, 9924, 9925, 9926, 9927, 9928, 9929, 9930, 9931, 9932, 9933, 9934, 9935, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9945, 9946, 9947, 9948, 9949, 9950, 9951, 9952, 9953, 9954, 9955, 9956, 9957 or 9958.
     * @type {string}
     * @memberof Contact
     */
    'si_identifier_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'si_identifier'?: string;
    /**
     * Should be a valid invoice workflow id.
     * @type {string}
     * @memberof Contact
     */
    'invoice_workflow_id'?: string;
    /**
     * Should be a valid estimate workflow id.
     * @type {string}
     * @memberof Contact
     */
    'estimate_workflow_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'email_ubl'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Contact
     */
    'direct_debit'?: boolean;
}
/**
 * Object for when creating contacts.
 * @export
 * @interface ContactCreate
 */
export interface ContactCreate {
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactCreate
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'zipcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'city'?: string;
    /**
     * ISO two-character country code, e.g. NL or DE.
     * @type {string}
     * @memberof ContactCreate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'phone'?: string;
    /**
     * Can be Email, Simplerinvoicing, Post or Manual.
     * @type {string}
     * @memberof ContactCreate
     */
    'delivery_method'?: string;
    /**
     * Will be assigned automatically if empty. Should be unique for the administration.
     * @type {string}
     * @memberof ContactCreate
     */
    'customer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'tax_number'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactCreate
     */
    'firstname'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactCreate
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'chamber_of_commerce'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'bank_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'send_invoices_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof ContactCreate
     */
    'send_invoices_to_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'send_estimates_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof ContactCreate
     */
    'send_estimates_to_email'?: string;
    /**
     * When true, all other SEPA fields are required.
     * @type {boolean}
     * @memberof ContactCreate
     */
    'sepa_active'?: boolean;
    /**
     * Should be a valid IBAN.
     * @type {string}
     * @memberof ContactCreate
     */
    'sepa_iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'sepa_iban_account_name'?: string;
    /**
     * Should be a valid BIC.
     * @type {string}
     * @memberof ContactCreate
     */
    'sepa_bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'sepa_mandate_id'?: string;
    /**
     * Should be a date in the past.
     * @type {string}
     * @memberof ContactCreate
     */
    'sepa_mandate_date'?: string;
    /**
     * Can be RCUR, FRST, OOFF or FNAL.
     * @type {string}
     * @memberof ContactCreate
     */
    'sepa_sequence_type'?: string;
    /**
     * Can be 0002, 0007, 0009, 0037, 0060, 0088, 0096, 0097, 0106, 0130, 0135, 0142, 0151, 0183, 0184, 0190, 0191, 0192, 0193, 0195, 0196, 0198, 0199, 0200, 0201, 0202, 0204, 0208, 0209, 9901, 9902, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9915, 9917, 9918, 9919, 9920, 9921, 9922, 9923, 9924, 9925, 9926, 9927, 9928, 9929, 9930, 9931, 9932, 9933, 9934, 9935, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9945, 9946, 9947, 9948, 9949, 9950, 9951, 9952, 9953, 9954, 9955, 9956, 9957 or 9958.
     * @type {string}
     * @memberof ContactCreate
     */
    'si_identifier_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreate
     */
    'si_identifier'?: string;
    /**
     * Should be a valid invoice workflow id.
     * @type {string}
     * @memberof ContactCreate
     */
    'invoice_workflow_id'?: string;
    /**
     * Should be a valid estimate workflow id.
     * @type {string}
     * @memberof ContactCreate
     */
    'estimate_workflow_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContactCreate
     */
    'email_ubl'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContactCreate
     */
    'direct_debit'?: boolean;
    /**
     * 
     * @type {Array<ContactUpdateAllOfCustomFieldsAttributes>}
     * @memberof ContactCreate
     */
    'custom_fields_attributes'?: Array<ContactUpdateAllOfCustomFieldsAttributes>;
    /**
     * 
     * @type {Array<ContactCreateAllOfContactPerson>}
     * @memberof ContactCreate
     */
    'contact_person'?: Array<ContactCreateAllOfContactPerson>;
}
/**
 * 
 * @export
 * @interface ContactCreateAllOf
 */
export interface ContactCreateAllOf {
    /**
     * 
     * @type {Array<ContactCreateAllOfContactPerson>}
     * @memberof ContactCreateAllOf
     */
    'contact_person'?: Array<ContactCreateAllOfContactPerson>;
}
/**
 * 
 * @export
 * @interface ContactCreateAllOfContactPerson
 */
export interface ContactCreateAllOfContactPerson {
    /**
     * 
     * @type {string}
     * @memberof ContactCreateAllOfContactPerson
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactCreateAllOfContactPerson
     */
    'lastname'?: string;
}
/**
 * Object for when reading contacts.
 * @export
 * @interface ContactRead
 */
export interface ContactRead {
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactRead
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'zipcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'city'?: string;
    /**
     * ISO two-character country code, e.g. NL or DE.
     * @type {string}
     * @memberof ContactRead
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'phone'?: string;
    /**
     * Can be Email, Simplerinvoicing, Post or Manual.
     * @type {string}
     * @memberof ContactRead
     */
    'delivery_method'?: string;
    /**
     * Will be assigned automatically if empty. Should be unique for the administration.
     * @type {string}
     * @memberof ContactRead
     */
    'customer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'tax_number'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactRead
     */
    'firstname'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactRead
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'chamber_of_commerce'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'bank_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'send_invoices_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof ContactRead
     */
    'send_invoices_to_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'send_estimates_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof ContactRead
     */
    'send_estimates_to_email'?: string;
    /**
     * When true, all other SEPA fields are required.
     * @type {boolean}
     * @memberof ContactRead
     */
    'sepa_active'?: boolean;
    /**
     * Should be a valid IBAN.
     * @type {string}
     * @memberof ContactRead
     */
    'sepa_iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'sepa_iban_account_name'?: string;
    /**
     * Should be a valid BIC.
     * @type {string}
     * @memberof ContactRead
     */
    'sepa_bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'sepa_mandate_id'?: string;
    /**
     * Should be a date in the past.
     * @type {string}
     * @memberof ContactRead
     */
    'sepa_mandate_date'?: string;
    /**
     * Can be RCUR, FRST, OOFF or FNAL.
     * @type {string}
     * @memberof ContactRead
     */
    'sepa_sequence_type'?: string;
    /**
     * Can be 0002, 0007, 0009, 0037, 0060, 0088, 0096, 0097, 0106, 0130, 0135, 0142, 0151, 0183, 0184, 0190, 0191, 0192, 0193, 0195, 0196, 0198, 0199, 0200, 0201, 0202, 0204, 0208, 0209, 9901, 9902, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9915, 9917, 9918, 9919, 9920, 9921, 9922, 9923, 9924, 9925, 9926, 9927, 9928, 9929, 9930, 9931, 9932, 9933, 9934, 9935, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9945, 9946, 9947, 9948, 9949, 9950, 9951, 9952, 9953, 9954, 9955, 9956, 9957 or 9958.
     * @type {string}
     * @memberof ContactRead
     */
    'si_identifier_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactRead
     */
    'si_identifier'?: string;
    /**
     * Should be a valid invoice workflow id.
     * @type {string}
     * @memberof ContactRead
     */
    'invoice_workflow_id'?: string;
    /**
     * Should be a valid estimate workflow id.
     * @type {string}
     * @memberof ContactRead
     */
    'estimate_workflow_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContactRead
     */
    'email_ubl'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContactRead
     */
    'direct_debit'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ContactRead
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContactRead
     */
    'administration_id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContactRead
     */
    'notes'?: Array<string>;
    /**
     * 
     * @type {Array<CustomField>}
     * @memberof ContactRead
     */
    'custom_fields'?: Array<CustomField>;
    /**
     * 
     * @type {Array<ContactReadAllOfContactPeople>}
     * @memberof ContactRead
     */
    'contact_people'?: Array<ContactReadAllOfContactPeople>;
    /**
     * 
     * @type {boolean}
     * @memberof ContactRead
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Array<Event>}
     * @memberof ContactRead
     */
    'events'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface ContactReadAllOf
 */
export interface ContactReadAllOf {
    /**
     * 
     * @type {number}
     * @memberof ContactReadAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContactReadAllOf
     */
    'administration_id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContactReadAllOf
     */
    'notes'?: Array<string>;
    /**
     * 
     * @type {Array<CustomField>}
     * @memberof ContactReadAllOf
     */
    'custom_fields'?: Array<CustomField>;
    /**
     * 
     * @type {Array<ContactReadAllOfContactPeople>}
     * @memberof ContactReadAllOf
     */
    'contact_people'?: Array<ContactReadAllOfContactPeople>;
    /**
     * 
     * @type {boolean}
     * @memberof ContactReadAllOf
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Array<Event>}
     * @memberof ContactReadAllOf
     */
    'events'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface ContactReadAllOfContactPeople
 */
export interface ContactReadAllOfContactPeople {
    /**
     * 
     * @type {number}
     * @memberof ContactReadAllOfContactPeople
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContactReadAllOfContactPeople
     */
    'administration_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'department'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactReadAllOfContactPeople
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContactReadAllOfContactPeople
     */
    'version'?: number;
}
/**
 * Object for when creating contacts.
 * @export
 * @interface ContactUpdate
 */
export interface ContactUpdate {
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactUpdate
     */
    'company_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'zipcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'city'?: string;
    /**
     * ISO two-character country code, e.g. NL or DE.
     * @type {string}
     * @memberof ContactUpdate
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'phone'?: string;
    /**
     * Can be Email, Simplerinvoicing, Post or Manual.
     * @type {string}
     * @memberof ContactUpdate
     */
    'delivery_method'?: string;
    /**
     * Will be assigned automatically if empty. Should be unique for the administration.
     * @type {string}
     * @memberof ContactUpdate
     */
    'customer_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'tax_number'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactUpdate
     */
    'firstname'?: string;
    /**
     * A contact requires a non-blank company_name, firstname or lastname.
     * @type {string}
     * @memberof ContactUpdate
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'chamber_of_commerce'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'bank_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'send_invoices_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof ContactUpdate
     */
    'send_invoices_to_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'send_estimates_to_attention'?: string;
    /**
     * Should be one or more valid email addresses, separated by a comma.
     * @type {string}
     * @memberof ContactUpdate
     */
    'send_estimates_to_email'?: string;
    /**
     * When true, all other SEPA fields are required.
     * @type {boolean}
     * @memberof ContactUpdate
     */
    'sepa_active'?: boolean;
    /**
     * Should be a valid IBAN.
     * @type {string}
     * @memberof ContactUpdate
     */
    'sepa_iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'sepa_iban_account_name'?: string;
    /**
     * Should be a valid BIC.
     * @type {string}
     * @memberof ContactUpdate
     */
    'sepa_bic'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'sepa_mandate_id'?: string;
    /**
     * Should be a date in the past.
     * @type {string}
     * @memberof ContactUpdate
     */
    'sepa_mandate_date'?: string;
    /**
     * Can be RCUR, FRST, OOFF or FNAL.
     * @type {string}
     * @memberof ContactUpdate
     */
    'sepa_sequence_type'?: string;
    /**
     * Can be 0002, 0007, 0009, 0037, 0060, 0088, 0096, 0097, 0106, 0130, 0135, 0142, 0151, 0183, 0184, 0190, 0191, 0192, 0193, 0195, 0196, 0198, 0199, 0200, 0201, 0202, 0204, 0208, 0209, 9901, 9902, 9904, 9905, 9906, 9907, 9908, 9909, 9910, 9912, 9913, 9914, 9915, 9917, 9918, 9919, 9920, 9921, 9922, 9923, 9924, 9925, 9926, 9927, 9928, 9929, 9930, 9931, 9932, 9933, 9934, 9935, 9936, 9937, 9938, 9939, 9940, 9941, 9942, 9943, 9944, 9945, 9946, 9947, 9948, 9949, 9950, 9951, 9952, 9953, 9954, 9955, 9956, 9957 or 9958.
     * @type {string}
     * @memberof ContactUpdate
     */
    'si_identifier_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdate
     */
    'si_identifier'?: string;
    /**
     * Should be a valid invoice workflow id.
     * @type {string}
     * @memberof ContactUpdate
     */
    'invoice_workflow_id'?: string;
    /**
     * Should be a valid estimate workflow id.
     * @type {string}
     * @memberof ContactUpdate
     */
    'estimate_workflow_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContactUpdate
     */
    'email_ubl'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ContactUpdate
     */
    'direct_debit'?: boolean;
    /**
     * 
     * @type {Array<ContactUpdateAllOfCustomFieldsAttributes>}
     * @memberof ContactUpdate
     */
    'custom_fields_attributes'?: Array<ContactUpdateAllOfCustomFieldsAttributes>;
}
/**
 * 
 * @export
 * @interface ContactUpdateAllOf
 */
export interface ContactUpdateAllOf {
    /**
     * 
     * @type {Array<ContactUpdateAllOfCustomFieldsAttributes>}
     * @memberof ContactUpdateAllOf
     */
    'custom_fields_attributes'?: Array<ContactUpdateAllOfCustomFieldsAttributes>;
}
/**
 * 
 * @export
 * @interface ContactUpdateAllOfCustomFieldsAttributes
 */
export interface ContactUpdateAllOfCustomFieldsAttributes {
    /**
     * 
     * @type {number}
     * @memberof ContactUpdateAllOfCustomFieldsAttributes
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateAllOfCustomFieldsAttributes
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * 
     * @type {number}
     * @memberof CustomField
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'administration_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'link_entity_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'link_entity_type'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Event
     */
    'data'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'administration_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'invoice_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'invoice_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'financial_account_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'payment_transaction_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'transaction_identifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'price_base'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'payment_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'credit_invoice_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'financial_mutation_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'ledger_account_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'linked_payment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'manual_payment_action'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'updated_at'?: string;
}
/**
 * Object which describes a purchase invoice document.
 * @export
 * @interface PurchaseInvoice
 */
export interface PurchaseInvoice {
    /**
     * Should be a valid contact id.
     * @type {number}
     * @memberof PurchaseInvoice
     */
    'contact_id': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoice
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoice
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoice
     */
    'due_date'?: string;
    /**
     * ISO three-character currency code, e.g. EUR or USD.
     * @type {string}
     * @memberof PurchaseInvoice
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoice
     */
    'prices_are_incl_tax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoice
     */
    'revenue_invoice'?: boolean;
}
/**
 * Object for when creaing a purchase invoice.
 * @export
 * @interface PurchaseInvoiceCreate
 */
export interface PurchaseInvoiceCreate {
    /**
     * Should be a valid contact id.
     * @type {number}
     * @memberof PurchaseInvoiceCreate
     */
    'contact_id': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceCreate
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceCreate
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceCreate
     */
    'due_date'?: string;
    /**
     * ISO three-character currency code, e.g. EUR or USD.
     * @type {string}
     * @memberof PurchaseInvoiceCreate
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceCreate
     */
    'prices_are_incl_tax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceCreate
     */
    'revenue_invoice'?: boolean;
    /**
     * 
     * @type {Array<PurchaseInvoiceDetail>}
     * @memberof PurchaseInvoiceCreate
     */
    'details_attributes'?: Array<PurchaseInvoiceDetail>;
}
/**
 * 
 * @export
 * @interface PurchaseInvoiceCreateAllOf
 */
export interface PurchaseInvoiceCreateAllOf {
    /**
     * 
     * @type {Array<PurchaseInvoiceDetail>}
     * @memberof PurchaseInvoiceCreateAllOf
     */
    'details_attributes'?: Array<PurchaseInvoiceDetail>;
}
/**
 * 
 * @export
 * @interface PurchaseInvoiceDetail
 */
export interface PurchaseInvoiceDetail {
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetail
     */
    'description'?: string;
    /**
     * String with a date range: 20140101..20141231, presets are also allowed: this_month, prev_month, next_month, etc.
     * @type {string}
     * @memberof PurchaseInvoiceDetail
     */
    'period'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetail
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetail
     */
    'amount'?: string;
    /**
     * Should be a valid tax rate id.
     * @type {number}
     * @memberof PurchaseInvoiceDetail
     */
    'tax_rate_id'?: number;
    /**
     * Should be a valid ledger account id.
     * @type {number}
     * @memberof PurchaseInvoiceDetail
     */
    'ledger_account_id'?: number;
    /**
     * Should be a valid project id.
     * @type {number}
     * @memberof PurchaseInvoiceDetail
     */
    'project_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetail
     */
    'row_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceDetail
     */
    '_destroy'?: boolean;
}
/**
 * Object for when reading purchase invoice details.
 * @export
 * @interface PurchaseInvoiceDetailRead
 */
export interface PurchaseInvoiceDetailRead {
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailRead
     */
    'description'?: string;
    /**
     * String with a date range: 20140101..20141231, presets are also allowed: this_month, prev_month, next_month, etc.
     * @type {string}
     * @memberof PurchaseInvoiceDetailRead
     */
    'period'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailRead
     */
    'amount'?: string;
    /**
     * Should be a valid tax rate id.
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'tax_rate_id'?: number;
    /**
     * Should be a valid ledger account id.
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'ledger_account_id'?: number;
    /**
     * Should be a valid project id.
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'project_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'row_order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceDetailRead
     */
    '_destroy'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'administration_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'amount_decimal'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'total_price_excl_tax_with_discount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailRead
     */
    'total_price_excl_tax_with_discount_base'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseInvoiceDetailRead
     */
    'tax_report_reference'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailRead
     */
    'mandatory_tax_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailRead
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailRead
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PurchaseInvoiceDetailReadAllOf
 */
export interface PurchaseInvoiceDetailReadAllOf {
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'administration_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'amount_decimal'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'total_price_excl_tax_with_discount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'total_price_excl_tax_with_discount_base'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'tax_report_reference'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'mandatory_tax_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceDetailReadAllOf
     */
    'updated_at'?: string;
}
/**
 * Object for when reading purchase invoices.
 * @export
 * @interface PurchaseInvoiceRead
 */
export interface PurchaseInvoiceRead {
    /**
     * Should be a valid contact id.
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'contact_id': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'due_date'?: string;
    /**
     * ISO three-character currency code, e.g. EUR or USD.
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceRead
     */
    'prices_are_incl_tax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceRead
     */
    'revenue_invoice'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'administration_id'?: number;
    /**
     * 
     * @type {ContactRead}
     * @memberof PurchaseInvoiceRead
     */
    'contact'?: ContactRead;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'entry_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'state'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'exchange_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'tax_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'total_price_excl_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'total_price_excl_tax_base'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'total_price_incl_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'total_price_incl_tax_base'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceRead
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceRead
     */
    'version'?: number;
    /**
     * 
     * @type {Array<PurchaseInvoiceDetailRead>}
     * @memberof PurchaseInvoiceRead
     */
    'details'?: Array<PurchaseInvoiceDetailRead>;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof PurchaseInvoiceRead
     */
    'payments'?: Array<Payment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseInvoiceRead
     */
    'notes'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof PurchaseInvoiceRead
     */
    'attachments'?: Array<Attachment>;
    /**
     * 
     * @type {Array<Event>}
     * @memberof PurchaseInvoiceRead
     */
    'events'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface PurchaseInvoiceReadAllOf
 */
export interface PurchaseInvoiceReadAllOf {
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'administration_id'?: number;
    /**
     * 
     * @type {ContactRead}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'contact'?: ContactRead;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'entry_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'state'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'exchange_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'tax_number'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'total_price_excl_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'total_price_excl_tax_base'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'total_price_incl_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'total_price_incl_tax_base'?: number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'version'?: number;
    /**
     * 
     * @type {Array<PurchaseInvoiceDetailRead>}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'details'?: Array<PurchaseInvoiceDetailRead>;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'payments'?: Array<Payment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'notes'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'attachments'?: Array<Attachment>;
    /**
     * 
     * @type {Array<Event>}
     * @memberof PurchaseInvoiceReadAllOf
     */
    'events'?: Array<Event>;
}
/**
 * Object for when updating a purchase invoice.
 * @export
 * @interface PurchaseInvoiceUpdate
 */
export interface PurchaseInvoiceUpdate {
    /**
     * Should be a valid contact id.
     * @type {number}
     * @memberof PurchaseInvoiceUpdate
     */
    'contact_id': number;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceUpdate
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceUpdate
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof PurchaseInvoiceUpdate
     */
    'due_date'?: string;
    /**
     * ISO three-character currency code, e.g. EUR or USD.
     * @type {string}
     * @memberof PurchaseInvoiceUpdate
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceUpdate
     */
    'prices_are_incl_tax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PurchaseInvoiceUpdate
     */
    'revenue_invoice'?: boolean;
    /**
     * 
     * @type {Array<PurchaseInvoiceDetail>}
     * @memberof PurchaseInvoiceUpdate
     */
    'details_attributes'?: Array<PurchaseInvoiceDetail>;
}

/**
 * AdministrationsApi - axios parameter creator
 * @export
 */
export const AdministrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns all administrations associated with the account
         * @summary List all administrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdministrations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/administrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdministrationsApi - functional programming interface
 * @export
 */
export const AdministrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdministrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns all administrations associated with the account
         * @summary List all administrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdministrations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Administration>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdministrations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdministrationsApi - factory interface
 * @export
 */
export const AdministrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdministrationsApiFp(configuration)
    return {
        /**
         * This endpoint returns all administrations associated with the account
         * @summary List all administrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdministrations(options?: any): AxiosPromise<Array<Administration>> {
            return localVarFp.getAdministrations(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdministrationsApi - object-oriented interface
 * @export
 * @class AdministrationsApi
 * @extends {BaseAPI}
 */
export class AdministrationsApi extends BaseAPI {
    /**
     * This endpoint returns all administrations associated with the account
     * @summary List all administrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdministrationsApi
     */
    public getAdministrations(options?: AxiosRequestConfig) {
        return AdministrationsApiFp(this.configuration).getAdministrations(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new contact
         * @param {string} administrationId The administration you want to access
         * @param {ContactCreate} [contactCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: async (administrationId: string, contactCreate?: ContactCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('createContact', 'administrationId', administrationId)
            const localVarPath = `/{administrationId}/contacts`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contact
         * @param {string} administrationId The administration you want to access
         * @param {string} contactId The contact you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: async (administrationId: string, contactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('getContact', 'administrationId', administrationId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getContact', 'contactId', contactId)
            const localVarPath = `/{administrationId}/contacts/{contactId}`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all contacts
         * @param {string} administrationId The administration you want to access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: async (administrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('getContacts', 'administrationId', administrationId)
            const localVarPath = `/{administrationId}/contacts`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a contact
         * @param {string} administrationId The administration you want to access
         * @param {string} contactId The contact you want to retrieve
         * @param {ContactUpdate} [contactUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact: async (administrationId: string, contactId: string, contactUpdate?: ContactUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('updateContact', 'administrationId', administrationId)
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('updateContact', 'contactId', contactId)
            const localVarPath = `/{administrationId}/contacts/{contactId}`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)))
                .replace(`{${"contactId"}}`, encodeURIComponent(String(contactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new contact
         * @param {string} administrationId The administration you want to access
         * @param {ContactCreate} [contactCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContact(administrationId: string, contactCreate?: ContactCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContact(administrationId, contactCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contact
         * @param {string} administrationId The administration you want to access
         * @param {string} contactId The contact you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContact(administrationId: string, contactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContact(administrationId, contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve all contacts
         * @param {string} administrationId The administration you want to access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContacts(administrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContactRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContacts(administrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a contact
         * @param {string} administrationId The administration you want to access
         * @param {string} contactId The contact you want to retrieve
         * @param {ContactUpdate} [contactUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContact(administrationId: string, contactId: string, contactUpdate?: ContactUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContact(administrationId, contactId, contactUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new contact
         * @param {string} administrationId The administration you want to access
         * @param {ContactCreate} [contactCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(administrationId: string, contactCreate?: ContactCreate, options?: any): AxiosPromise<void> {
            return localVarFp.createContact(administrationId, contactCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contact
         * @param {string} administrationId The administration you want to access
         * @param {string} contactId The contact you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(administrationId: string, contactId: string, options?: any): AxiosPromise<ContactRead> {
            return localVarFp.getContact(administrationId, contactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all contacts
         * @param {string} administrationId The administration you want to access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(administrationId: string, options?: any): AxiosPromise<Array<ContactRead>> {
            return localVarFp.getContacts(administrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a contact
         * @param {string} administrationId The administration you want to access
         * @param {string} contactId The contact you want to retrieve
         * @param {ContactUpdate} [contactUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(administrationId: string, contactId: string, contactUpdate?: ContactUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateContact(administrationId, contactId, contactUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new contact
     * @param {string} administrationId The administration you want to access
     * @param {ContactCreate} [contactCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public createContact(administrationId: string, contactCreate?: ContactCreate, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createContact(administrationId, contactCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contact
     * @param {string} administrationId The administration you want to access
     * @param {string} contactId The contact you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContact(administrationId: string, contactId: string, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContact(administrationId, contactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all contacts
     * @param {string} administrationId The administration you want to access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public getContacts(administrationId: string, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getContacts(administrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a contact
     * @param {string} administrationId The administration you want to access
     * @param {string} contactId The contact you want to retrieve
     * @param {ContactUpdate} [contactUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public updateContact(administrationId: string, contactId: string, contactUpdate?: ContactUpdate, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).updateContact(administrationId, contactId, contactUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PurchaseInvoicesApi - axios parameter creator
 * @export
 */
export const PurchaseInvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new purchase invoice document
         * @param {string} administrationId The administration you want to access
         * @param {PurchaseInvoiceCreate} [purchaseInvoiceCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseInvoice: async (administrationId: string, purchaseInvoiceCreate?: PurchaseInvoiceCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('createPurchaseInvoice', 'administrationId', administrationId)
            const localVarPath = `/{administrationId}/documents/purchase_invoices`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseInvoiceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get purchase invoice
         * @param {string} administrationId The administration you want to access
         * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchaseInvoice: async (administrationId: string, purchaseInvoicesId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('getPurchaseInvoice', 'administrationId', administrationId)
            // verify required parameter 'purchaseInvoicesId' is not null or undefined
            assertParamExists('getPurchaseInvoice', 'purchaseInvoicesId', purchaseInvoicesId)
            const localVarPath = `/{administrationId}/documents/purchase_invoices/{purchaseInvoicesId}`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)))
                .replace(`{${"purchaseInvoicesId"}}`, encodeURIComponent(String(purchaseInvoicesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get purchase invoices
         * @param {string} administrationId The administration you want to access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchaseInvoices: async (administrationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('getPurchaseInvoices', 'administrationId', administrationId)
            const localVarPath = `/{administrationId}/documents/purchase_invoices`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a purchase invoice
         * @param {string} administrationId The administration you want to access
         * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
         * @param {PurchaseInvoiceUpdate} [purchaseInvoiceUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePurchaseInvoice: async (administrationId: string, purchaseInvoicesId: string, purchaseInvoiceUpdate?: PurchaseInvoiceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'administrationId' is not null or undefined
            assertParamExists('updatePurchaseInvoice', 'administrationId', administrationId)
            // verify required parameter 'purchaseInvoicesId' is not null or undefined
            assertParamExists('updatePurchaseInvoice', 'purchaseInvoicesId', purchaseInvoicesId)
            const localVarPath = `/{administrationId}/documents/purchase_invoices/{purchaseInvoicesId}`
                .replace(`{${"administrationId"}}`, encodeURIComponent(String(administrationId)))
                .replace(`{${"purchaseInvoicesId"}}`, encodeURIComponent(String(purchaseInvoicesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)

            // authentication ApiToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseInvoiceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PurchaseInvoicesApi - functional programming interface
 * @export
 */
export const PurchaseInvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PurchaseInvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new purchase invoice document
         * @param {string} administrationId The administration you want to access
         * @param {PurchaseInvoiceCreate} [purchaseInvoiceCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPurchaseInvoice(administrationId: string, purchaseInvoiceCreate?: PurchaseInvoiceCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPurchaseInvoice(administrationId, purchaseInvoiceCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get purchase invoice
         * @param {string} administrationId The administration you want to access
         * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPurchaseInvoice(administrationId: string, purchaseInvoicesId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchaseInvoiceRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPurchaseInvoice(administrationId, purchaseInvoicesId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get purchase invoices
         * @param {string} administrationId The administration you want to access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPurchaseInvoices(administrationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PurchaseInvoiceRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPurchaseInvoices(administrationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a purchase invoice
         * @param {string} administrationId The administration you want to access
         * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
         * @param {PurchaseInvoiceUpdate} [purchaseInvoiceUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePurchaseInvoice(administrationId: string, purchaseInvoicesId: string, purchaseInvoiceUpdate?: PurchaseInvoiceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePurchaseInvoice(administrationId, purchaseInvoicesId, purchaseInvoiceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PurchaseInvoicesApi - factory interface
 * @export
 */
export const PurchaseInvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PurchaseInvoicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new purchase invoice document
         * @param {string} administrationId The administration you want to access
         * @param {PurchaseInvoiceCreate} [purchaseInvoiceCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPurchaseInvoice(administrationId: string, purchaseInvoiceCreate?: PurchaseInvoiceCreate, options?: any): AxiosPromise<void> {
            return localVarFp.createPurchaseInvoice(administrationId, purchaseInvoiceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get purchase invoice
         * @param {string} administrationId The administration you want to access
         * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchaseInvoice(administrationId: string, purchaseInvoicesId: string, options?: any): AxiosPromise<PurchaseInvoiceRead> {
            return localVarFp.getPurchaseInvoice(administrationId, purchaseInvoicesId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get purchase invoices
         * @param {string} administrationId The administration you want to access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchaseInvoices(administrationId: string, options?: any): AxiosPromise<Array<PurchaseInvoiceRead>> {
            return localVarFp.getPurchaseInvoices(administrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a purchase invoice
         * @param {string} administrationId The administration you want to access
         * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
         * @param {PurchaseInvoiceUpdate} [purchaseInvoiceUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePurchaseInvoice(administrationId: string, purchaseInvoicesId: string, purchaseInvoiceUpdate?: PurchaseInvoiceUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updatePurchaseInvoice(administrationId, purchaseInvoicesId, purchaseInvoiceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PurchaseInvoicesApi - object-oriented interface
 * @export
 * @class PurchaseInvoicesApi
 * @extends {BaseAPI}
 */
export class PurchaseInvoicesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new purchase invoice document
     * @param {string} administrationId The administration you want to access
     * @param {PurchaseInvoiceCreate} [purchaseInvoiceCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseInvoicesApi
     */
    public createPurchaseInvoice(administrationId: string, purchaseInvoiceCreate?: PurchaseInvoiceCreate, options?: AxiosRequestConfig) {
        return PurchaseInvoicesApiFp(this.configuration).createPurchaseInvoice(administrationId, purchaseInvoiceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get purchase invoice
     * @param {string} administrationId The administration you want to access
     * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseInvoicesApi
     */
    public getPurchaseInvoice(administrationId: string, purchaseInvoicesId: string, options?: AxiosRequestConfig) {
        return PurchaseInvoicesApiFp(this.configuration).getPurchaseInvoice(administrationId, purchaseInvoicesId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get purchase invoices
     * @param {string} administrationId The administration you want to access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseInvoicesApi
     */
    public getPurchaseInvoices(administrationId: string, options?: AxiosRequestConfig) {
        return PurchaseInvoicesApiFp(this.configuration).getPurchaseInvoices(administrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a purchase invoice
     * @param {string} administrationId The administration you want to access
     * @param {string} purchaseInvoicesId The purchase invoice you want to retrieve
     * @param {PurchaseInvoiceUpdate} [purchaseInvoiceUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PurchaseInvoicesApi
     */
    public updatePurchaseInvoice(administrationId: string, purchaseInvoicesId: string, purchaseInvoiceUpdate?: PurchaseInvoiceUpdate, options?: AxiosRequestConfig) {
        return PurchaseInvoicesApiFp(this.configuration).updatePurchaseInvoice(administrationId, purchaseInvoicesId, purchaseInvoiceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


